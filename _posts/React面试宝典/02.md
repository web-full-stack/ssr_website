---
title: 为什么 React 要用 JSX？
date: 2021-05-17 00:00:02
tags:
categories: react面试
---

### 破题

无论是面试还是晋升，“为什么采用该技术方案”这一类问题是主考官最爱提的。这类问题其实在考察你的两个方面：

- 技术广度，深挖知识面涉猎广度，对流行框架的模板方案是否知悉了解；
- 技术方案调研能力。

通过以上的分析，我们可以使用 三步走技巧

- 一句话解释 JSX。首先能一句话说清楚 JSX 到底是什么。

- 核心概念。JSX 用于解决什么问题？如何使用？

- 方案对比。与其他的方案对比，说明 React 选用 JSX 的必要性。

### 入手

#### 一句话解释

按照 React 官方的解释，JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。

#### 核心概念

其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。

```js
class Hello extends React.Component {
  render() {
    return React.createElement("div", null, `Hello ${this.props.toWhat}`);
  }
}
ReactDOM.render(
  React.createElement(Hello, { toWhat: "World" }, null),
  document.getElementById("root")
);
```

而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。

```js
class Hello extends React.Component {
  render() {
    return <div>Hello {this.props.toWhat}</div>;
  }
}
ReactDOM.render(<Hello toWhat="World" />, document.getElementById("root"));
```

通过这样的对比，你可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。
因为 React 需要将组件转化为虚拟 DOM 树，所以我们在编写代码时，实际上是在手写一棵结构树。而 XML 在树结构的描述上天生具有可读性强的优势。
但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。

#### 方案对比

##### 设计初衷

谈论其他方案之前，就需要谈到 React 的设计初衷，也是计算机科学里面一个非常重要的概念，叫作关注点分离。

> 关注点分离在计算机科学中，是将代码分隔为不同部分的设计原则，是面向对象的程序设计的核心概念。其中每一部分会有各自的关注焦点。
> 关注点分离的价值在于简化程序的开发和维护。当关注点分开时，各部分可以重复使用，以及独立开发和更新。具有特殊价值的是能够稍后改进或修改一段代码，而无须知道其他部分的细节必须对这些部分进行相应的更改。

在 React 中，关注点的基本单位是组件。在接触一段时间 React 开发后，你会发现 React 单个组件是高内聚的，组件之间耦合度很低。

那模板不能做到吗？

React 团队认为引入模板是一种不佳的实现。 因为模板分离了技术栈，而非关注点的模板同时又引入了更多的概念。比如新的模板语法、模板指令等。JSX 并不会引入太多新的概念，它仍然是 JavaScript，就连条件表达式和循环都仍然是 JavaScript 的方式。

### 答题

在回答问题之前，我首先解释下什么是 JSX 吧。JSX 是一个 JavaScript 的语法扩展，结构类似 XML。

JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。

所以从这里可以看出，React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。

接下来与 JSX 以外的三种技术方案进行对比。

首先是模板，React 团队认为模板不应该是开发过程中的关注点，因为引入了模板语法、模板指令等概念，是一种不佳的实现方案。

其次是模板字符串，模板字符串编写的结构会造成多次内部嵌套，使整个结构变得复杂，并且优化代码提示也会变得困难重重。

最后是 JXON，同样因为代码提示困难的原因而被放弃。

所以 React 最后选用了 JSX，因为 JSX 与其设计思想贴合，不需要引入过多新的概念，对编辑器的代码提示也极为友好。

### 进阶

Babel 插件如何实现 JSX 到 JS 的编译？

它的实现原理是这样的。Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 React.createElement 的函数。

```js
module.exports = function (babel) {
  var t = babel.types;
  return {
    name: "custom-jsx-plugin",
    visitor: {
      JSXElement(path) {
        var openingElement = path.node.openingElement;
        var tagName = openingElement.name.name;
        var args = [];
        args.push(t.stringLiteral(tagName));
        var attribs = t.nullLiteral();
        args.push(attribs);
        var reactIdentifier = t.identifier("React"); //object
        var createElementIdentifier = t.identifier("createElement");
        var callee = t.memberExpression(
          reactIdentifier,
          createElementIdentifier
        );
        var callExpression = t.callExpression(callee, args);
        callExpression.arguments = callExpression.arguments.concat(
          path.node.children
        );
        path.replaceWith(callExpression, path.node);
      },
    },
  };
};
```

这段代码是如何运行起来的。

你可以先新建一个目录，就叫 babelTest 吧。

然后新建一个 .babelrc 文件，这个文件是 babel 的配置文件。因为需要自己实现 plugins，所以先写上。

```
{
  "plugins": []
}
```

然后实现一个解析 JSX 文件的插件，取名叫 ./jsx-parser。

```
module.exports = function () {
  return {
    manipulateOptions: function manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsx");
    }
  };
};
```

把它加入 plugins 里，就像下面这样：

```
{
  "plugins": ["./jsx-parser"]
}
```

这是第一步，可以识别 jsx 文件，那么第二步来放一下上一讲讲到的源码，新建一个 jsx-plugin 文件，然后把上一讲的源码复制进去。

```
{
  "plugins": ["jsx-plugin", "./jsx-parser"]
}
```

接下来就需要一个 jsx 文件进行试验，新建 hello.jsx，写入下面的内容：

```
function Test() {
  return <div><a>Hello~~~</a></div>
}
```

完工，最后是用 babel 执行它。

```
babel
bash: command not found: babel
```

等等？为什么不能执行呢？因为没安装 babel 呀。

```

npm install babel-cli -g
babel hello.jsx

```

最后，看看输出，是不是有种彻底征服 JSX 的感觉呀？
